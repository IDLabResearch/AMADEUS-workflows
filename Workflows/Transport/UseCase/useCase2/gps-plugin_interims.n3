# EYE Components for GPS -- Jos De Roo

PREFIX math: <http://www.w3.org/2000/10/swap/math#>
PREFIX list: <http://www.w3.org/2000/10/swap/list#>
PREFIX log: <http://www.w3.org/2000/10/swap/log#>
PREFIX e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>
PREFIX gps: <http://josd.github.io/eye/reasoning/gps/gps-schema#>
PREFIX : <http://www.example.org#>

# find paths in the state space from initial state to goal state within limits
{?SCOPE gps:findpath (?Goal ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort))} <= {
    ?SCOPE gps:findpaths (() ?Goal () 0.0 0.0 1.0 1.0 ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort 1)).
}.
{?SCOPE gps:findpath (?Goal ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} <= {
    ?SCOPE gps:findpaths (() ?Goal () 0.0 0.0 1.0 1.0 ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount)).
}.

{?SCOPE gps:findpaths (?Maps ?Goal ?Path ?Duration ?Cost ?Belief ?Comfort ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} <= {
    ?SCOPE e:call ?Goal.
    {} e:becomes {?Path a :validPath.}.
    ("!") e:derive true.
}.
{?SCOPE gps:findpaths (?Maps_s ?Goal ?Path_s ?Duration_s ?Cost_s ?Belief_s ?Comfort_s ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} <= {
    {?Map gps:description (?From ?Transition ?To ?Action ?Duration_n ?Cost_n ?Belief_n ?Comfort_n)} <= ?Where.
    ?Scope e:fail {?Action :is :blocked}.
    ?SCOPE e:call ?From.
    ?SCOPE e:call ?Where.
    ?Map gps:description (?From ?Transition ?To ?Action ?Duration_n ?Cost_n ?Belief_n ?Comfort_n).
    ((?Map) ?Maps_s ) list:append ?Maps_t.
    ?Maps_t gps:stagecount ?Stagecount.
    ?Stagecount math:notGreaterThan ?MaxStagecount.
    (?Duration_s ?Duration_n) math:sum ?Duration_t.
    ?Duration_t math:notGreaterThan ?MaxDuration.
    (?Cost_s ?Cost_n) math:sum ?Cost_t.
    ?Cost_t math:notGreaterThan ?MaxCost.
    (?Belief_s ?Belief_n) math:product ?Belief_t.
    ?Belief_t math:notLessThan ?MinBelief.
    (?Comfort_s ?Comfort_n) math:product ?Comfort_t.
    ?Comfort_t math:notLessThan ?MinComfort.
#no step twice condition. Can be switched on and off
    ?Action :notIn ?Path_s.

# not too many steps from the same map
#    ?Maps_t :maxMapStay 2.

# every step needs to be a map change, unless we reach an interim goal (that is for transport)
    ?Maps_t :transportPath ?Action.



    (?Path_s (?Action)) list:append ?Path_t.



    ?From e:becomes ?To.
    {?SCOPE gps:findpaths (?Maps_t ?Goal ?Path_t ?Duration_t ?Cost_t ?Belief_t ?Comfort_t ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} e:finalize {?To e:becomes ?From}.
}.

# counting the number of stages (a stage is a sequence of steps in the same map)
{() gps:stagecount 1} <= {
}.
{?A gps:stagecount ?B} <= {
    ?A e:firstRest (?C ?D).
    ?D e:firstRest (?E ?F).
    ?C log:notEqualTo ?E.
    ("!") e:derive true.
    ?D gps:stagecount ?G.
    (?G 1) math:sum ?B.
}.
{?A gps:stagecount ?B} <= {
    ?A e:firstRest (?C ?D).
    ?D gps:stagecount ?B.
}.

#no action twice
{?Action :notIn ?Path_s.}
<=
{
?Action list:in ?Path_s.
("!") e:derive true. ("fail") e:derive true.
}.

{?Action :notIn ?Path_s.}<={}.


# do not stay too long in one map
{(?a) :maxMapStay ?max.}
<=
{
("!") e:derive true.
}.

{?A :maxMapStay ?max.}
<=
{
?A e:firstRest (?C ?D).


?D e:firstRest (?E ?F).
?C log:notEqualTo ?E.
("!") e:derive true.
}.


{?A :maxMapStay ?max.}
<=
{
?A e:firstRest (?C ?D).
?D e:firstRest (?E ?F).
?C log:equalTo ?E.
(?max 1) math:difference ?diff.
?diff math:greaterThan 0.
?D :maxMapStay ?diff.
}.

# transport
{(?a) :transportPath ?Action.}
<=
{
("!") e:derive true.
}.


{?A :transportPath ?Action.}
<=
{

?A e:firstRest (?C ?D).


?D e:firstRest (?E ?F).
?C log:notEqualTo ?E.
("!") e:derive true.
}.

 {?A :transportPath (?a ?b ?c).}
<=
 {
?a a :interimGoal .
}.


